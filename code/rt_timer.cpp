#pragma once 

//
// Timer
//

enum TimerType {
	TIMER_TYPE_BEGIN,
	TIMER_TYPE_END,
};

struct TimerInfo {
	bool initialised;
	bool stringsSaved;

	char* file;
	char* function;
	char* name;
	int line, line2;
	uint type;

	float color[3];
};

#define CYCLEBUFFERSIZE 120
#pragma pack(push,1)

struct TimerSlot {
	char type;
	uint threadId;
	char timerIndex;
	u64 cycles;

	// @Hack.
	uint size;
};
#pragma pack(pop)

struct GraphSlot {
	char threadIndex;
	char timerIndex;
	char stackIndex;
	u64 cycles;
	uint size;
};

struct Timings {
	u64 cycles;
	int hits;
	u64 cyclesOverHits;
};

struct  Timer {
	bool isInitialised;
	int timerInfoCount;
	TimerInfo timerInfos[32]; // timerInfoCount
	TimerSlot* timerBuffer;
	int bufferSize;
	int bufferIndex;
};

extern Timer* globalTimer;

inline uint getThreadID() {
	char *threadLocalStorage = (char *)__readgsqword(0x30);
	uint threadID = *(uint *)(threadLocalStorage + 0x48);

	return threadID;
}

void addTimerSlot(int timerIndex, int type) {
	int id = InterlockedIncrement((LONG*)(&globalTimer->bufferIndex));
	id--;
	TimerSlot* slot = globalTimer->timerBuffer + id;
	slot->cycles = __rdtsc();
	slot->type = type;
	slot->threadId = getThreadID();
	slot->timerIndex = timerIndex;
}

void addTimerSlotAndInfo(int timerIndex, int type, char* file, char* function, int line, char* name = "") {

	TimerInfo* timerInfo = globalTimer->timerInfos + timerIndex;

	// if(getThreadID() == 0 && !timerInfo->initialised) {
	if(!timerInfo->initialised) {
		timerInfo->initialised = true;
		timerInfo->file = file;
		timerInfo->function = function;
		timerInfo->line = line;
		timerInfo->type = type;
		timerInfo->name = name;
	}

	addTimerSlot(timerIndex, type);
}

struct TimerBlock {
	int counter;

	TimerBlock(int counter, char* file, char* function, int line, char* name = "") {

		this->counter = counter;
		addTimerSlotAndInfo(counter, TIMER_TYPE_BEGIN, file, function, line, name);
	}

	~TimerBlock() {
		addTimerSlot(counter, TIMER_TYPE_END);
	}
};

#define TIMER_BLOCK() \
	TimerBlock timerBlock##__LINE__(__COUNTER__, __FILE__, __FUNCTION__, __LINE__);

#define TIMER_BLOCK_NAMED(name) \
	TimerBlock timerBlock##__LINE__(__COUNTER__, __FILE__, __FUNCTION__, __LINE__, name);

#define TIMER_BLOCK_BEGIN(ID) \
	const int timerCounter##ID = __COUNTER__; \
	addTimerSlotAndInfo(timerCounter##ID, TIMER_TYPE_BEGIN, __FILE__, __FUNCTION__, __LINE__); 

#define TIMER_BLOCK_BEGIN_NAMED(ID, name) \
	const int timerCounter##ID = __COUNTER__; \
	addTimerSlotAndInfo(timerCounter##ID, TIMER_TYPE_BEGIN, __FILE__, __FUNCTION__, __LINE__, name); 

#define TIMER_BLOCK_END(ID) \
	addTimerSlot(timerCounter##ID, TIMER_TYPE_END);
